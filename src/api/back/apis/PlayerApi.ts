/* tslint:disable */
/* eslint-disable */
/**
 * Public REST api for dota2classic
 * All stuff
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import useSWR, { ConfigInterface } from "swr";

import {
  LeaderboardEntryDto,
  LeaderboardEntryDtoFromJSON,
  LeaderboardEntryDtoToJSON,
  MyProfileDto,
  MyProfileDtoFromJSON,
  MyProfileDtoToJSON,
  PartyDto,
  PartyDtoFromJSON,
  PartyDtoToJSON,
  PlayerPreviewDto,
  PlayerPreviewDtoFromJSON,
  PlayerPreviewDtoToJSON,
  PlayerSummaryDto,
  PlayerSummaryDtoFromJSON,
  PlayerSummaryDtoToJSON
} from "../models";

export interface PlayerControllerLeaderboardRequest {
  version?: string;
}

export interface PlayerControllerPlayerSummaryRequest {
  id: string;
}

export interface PlayerControllerSearchRequest {
  name: string;
}

/**
 *
 */
export class PlayerApi extends runtime.BaseAPI {
  /**
   */
  private async playerControllerConnectionsRaw(): Promise<runtime.ApiResponse<MyProfileDto>> {
    this.playerControllerConnectionsValidation();
    const context = this.playerControllerConnectionsContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => MyProfileDtoFromJSON(jsonValue));
  }

  /**
   */
  private playerControllerConnectionsValidation() {}

  /**
   */
  playerControllerConnectionsContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/v1/player/connections`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  playerControllerConnections = async (): Promise<MyProfileDto> => {
    const response = await this.playerControllerConnectionsRaw();
    return await response.value();
  };

  usePlayerControllerConnections(config?: ConfigInterface<MyProfileDto, Error>) {
    let valid = true;

    const context = this.playerControllerConnectionsContext();
    return useSWR(JSON.stringify(context), valid ? () => this.playerControllerConnections() : undefined, config);
  }

  /**
   */
  private async playerControllerLeaderboardRaw(
    requestParameters: PlayerControllerLeaderboardRequest
  ): Promise<runtime.ApiResponse<Array<LeaderboardEntryDto>>> {
    this.playerControllerLeaderboardValidation(requestParameters);
    const context = this.playerControllerLeaderboardContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(LeaderboardEntryDtoFromJSON));
  }

  /**
   */
  private playerControllerLeaderboardValidation(requestParameters: PlayerControllerLeaderboardRequest) {}

  /**
   */
  playerControllerLeaderboardContext(requestParameters: PlayerControllerLeaderboardRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.version !== undefined) {
      queryParameters["version"] = requestParameters.version;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/v1/player/leaderboard`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  playerControllerLeaderboard = async (version?: string): Promise<Array<LeaderboardEntryDto>> => {
    const response = await this.playerControllerLeaderboardRaw({ version: version });
    return await response.value();
  };

  usePlayerControllerLeaderboard(version?: string, config?: ConfigInterface<Array<LeaderboardEntryDto>, Error>) {
    let valid = true;

    const context = this.playerControllerLeaderboardContext({ version: version! });
    return useSWR(
      JSON.stringify(context),
      valid ? () => this.playerControllerLeaderboard(version!) : undefined,
      config
    );
  }

  /**
   */
  private async playerControllerMeRaw(): Promise<runtime.ApiResponse<PlayerSummaryDto>> {
    this.playerControllerMeValidation();
    const context = this.playerControllerMeContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PlayerSummaryDtoFromJSON(jsonValue));
  }

  /**
   */
  private playerControllerMeValidation() {}

  /**
   */
  playerControllerMeContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/v1/player/me`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  playerControllerMe = async (): Promise<PlayerSummaryDto> => {
    const response = await this.playerControllerMeRaw();
    return await response.value();
  };

  usePlayerControllerMe(config?: ConfigInterface<PlayerSummaryDto, Error>) {
    let valid = true;

    const context = this.playerControllerMeContext();
    return useSWR(JSON.stringify(context), valid ? () => this.playerControllerMe() : undefined, config);
  }

  /**
   */
  private async playerControllerMyPartyRaw(): Promise<runtime.ApiResponse<PartyDto>> {
    this.playerControllerMyPartyValidation();
    const context = this.playerControllerMyPartyContext();
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PartyDtoFromJSON(jsonValue));
  }

  /**
   */
  private playerControllerMyPartyValidation() {}

  /**
   */
  playerControllerMyPartyContext(): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === "function" ? token("bearer", []) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    return {
      path: `/v1/player/party`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  playerControllerMyParty = async (): Promise<PartyDto> => {
    const response = await this.playerControllerMyPartyRaw();
    return await response.value();
  };

  usePlayerControllerMyParty(config?: ConfigInterface<PartyDto, Error>) {
    let valid = true;

    const context = this.playerControllerMyPartyContext();
    return useSWR(JSON.stringify(context), valid ? () => this.playerControllerMyParty() : undefined, config);
  }

  /**
   */
  private async playerControllerPlayerSummaryRaw(
    requestParameters: PlayerControllerPlayerSummaryRequest
  ): Promise<runtime.ApiResponse<PlayerSummaryDto>> {
    this.playerControllerPlayerSummaryValidation(requestParameters);
    const context = this.playerControllerPlayerSummaryContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => PlayerSummaryDtoFromJSON(jsonValue));
  }

  /**
   */
  private playerControllerPlayerSummaryValidation(requestParameters: PlayerControllerPlayerSummaryRequest) {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        "id",
        "Required parameter requestParameters.id was null or undefined when calling playerControllerPlayerSummary."
      );
    }
  }

  /**
   */
  playerControllerPlayerSummaryContext(requestParameters: PlayerControllerPlayerSummaryRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/v1/player/summary/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  playerControllerPlayerSummary = async (id: string): Promise<PlayerSummaryDto> => {
    const response = await this.playerControllerPlayerSummaryRaw({ id: id });
    return await response.value();
  };

  usePlayerControllerPlayerSummary(id: string, config?: ConfigInterface<PlayerSummaryDto, Error>) {
    let valid = true;

    if (id === null || id === undefined || Number.isNaN(id)) {
      valid = false;
    }

    const context = this.playerControllerPlayerSummaryContext({ id: id! });
    return useSWR(JSON.stringify(context), valid ? () => this.playerControllerPlayerSummary(id!) : undefined, config);
  }

  /**
   */
  private async playerControllerSearchRaw(
    requestParameters: PlayerControllerSearchRequest
  ): Promise<runtime.ApiResponse<Array<PlayerPreviewDto>>> {
    this.playerControllerSearchValidation(requestParameters);
    const context = this.playerControllerSearchContext(requestParameters);
    const response = await this.request(context);

    return new runtime.JSONApiResponse(response, jsonValue => jsonValue.map(PlayerPreviewDtoFromJSON));
  }

  /**
   */
  private playerControllerSearchValidation(requestParameters: PlayerControllerSearchRequest) {
    if (requestParameters.name === null || requestParameters.name === undefined) {
      throw new runtime.RequiredError(
        "name",
        "Required parameter requestParameters.name was null or undefined when calling playerControllerSearch."
      );
    }
  }

  /**
   */
  playerControllerSearchContext(requestParameters: PlayerControllerSearchRequest): runtime.RequestOpts {
    const queryParameters: any = {};

    if (requestParameters.name !== undefined) {
      queryParameters["name"] = requestParameters.name;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    return {
      path: `/v1/player/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    };
  }

  /**
   */
  playerControllerSearch = async (name: string): Promise<Array<PlayerPreviewDto>> => {
    const response = await this.playerControllerSearchRaw({ name: name });
    return await response.value();
  };

  usePlayerControllerSearch(name: string, config?: ConfigInterface<Array<PlayerPreviewDto>, Error>) {
    let valid = true;

    if (name === null || name === undefined || Number.isNaN(name)) {
      valid = false;
    }

    const context = this.playerControllerSearchContext({ name: name! });
    return useSWR(JSON.stringify(context), valid ? () => this.playerControllerSearch(name!) : undefined, config);
  }
}
